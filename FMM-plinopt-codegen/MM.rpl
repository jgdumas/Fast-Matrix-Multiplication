#!/bin/csh
# ==========================================================================
# Fast-Matrix-Multiplication library
# Authors: J-G. Dumas, C. Pernet, A. Sedoglavic
# ==========================================================================
# ==========================================================================
# Matlab Matrix Multiplication generator from Straight-Line Programs
# ==========================================================================
# Usage: L.slp R.slp P.slp m k n r name
#   MM of (m x k) times (k x n), using r multiplications
#   L.slp R.slp P.slp: left/right/product linear operators
#   L corresponds to a (r x (m.k)) matrix
#   R corresponds to a (r x (k.n)) matrix
#   P corresponds to a ((m.n) x r) matrix
#   produces 2 Matlab programs: 'name.m' and 'name_m_k_n.m'
# ==========================================================================
# Examples:
# ./MM.rpl /tmp/Lw.slp /tmp/Rw.slp /tmp/Pw.slp 2 2 2 7 SW
# ./MM.rpl L_3x3x6_52.slp R_3x3x6_106.slp P_3x3x6_107.slp 3 3 6 40 FMM
# ./MM.rpl L_3x6x3.slp R_3x6x3.slp P_3x6x3.slp 3 6 3 40 FMM
# ./MM.rpl L_6x3x3.slp R_6x3x3.slp P_6x3x3.slp 6 3 3 40 FMM
# ./MM.rpl L_3x3x6_accurate.slp R_3x3x6_accurate.slp P_3x3x6_accurate.slp 3 3 6 40 FMMa
# ./MM.rpl L_3x6x3_accurate.slp R_3x6x3_accurate.slp P_3x6x3_accurate.slp 3 6 3 40 FMMa
# ./MM.rpl L_6x3x3_accurate.slp R_6x3x3_accurate.slp P_6x3x3_accurate.slp 6 3 3 40 FMMa
# ==========================================================================

set Lslp = $1		# Left linear map
set Rslp = $2		# Right linear map
set Pslp = $3		# Product linear map
set m = $4		# LHS row dimension
set k = $5		# LHS column dimension & RHS row dimension
set n = $6		# RHS column dimension
set r = $7		# Tensor rank
set PathFname = $8	# Function name
set PathCname = "${PathFname}_${m}_${k}_${n}"
set Fname = `basename ${PathFname}`	# Function name
set Cname = "${Fname}_${m}_${k}_${n}"

echo "# Writing core algorithm to ${PathCname}.m"

cat > ${PathCname}.m<< EOF
function C = $Cname(A, B, nmin, level)
[m,k] = size(A);
[k,n] = size(B);
EOF
echo "% Recursively cuts into nmin*${m}^l x nmin*${k}^l x nmin*${n}^l blocks, with decreasing maximal l" >> ${PathCname}.m
echo "if (m<=nmin)||(k<=nmin)||(n<=nmin)||(m<$m)||(k<$k)||(n<$n)" >> ${PathCname}.m
cat >> ${PathCname}.m<< EOF
  % fprintf("# MM Direct: %d x %d x %d\n",m,k,n)
  C = A*B;
else
  C = zeros(m,n);
  mu=nmin;ku=nmin;nu=nmin;l=0;
  while (mu <= m) && (ku <= k) && (nu <= n)
EOF
echo "    l=l+1; mu=mu*$m; ku=ku*$k; nu=nu*$n;" >> ${PathCname}.m
echo "  end" >> ${PathCname}.m
echo "  l=l-1;mu=nmin*${m}^l; ku=nmin*${k}^l; nu=nmin*${n}^l;" >> ${PathCname}.m
cat >> ${PathCname}.m<< EOF
  if (mu < m) || (ku < k) || (nu < n)
    % fprintf("# Core SubMatrix[%d]: %d x %d x %d\n",l,mu,ku,nu)
EOF
echo "    C(1:mu,1:nu)=${Cname}(A(1:mu,1:ku),B(1:ku,1:nu),nmin, level);" >> ${PathCname}.m
cat >> ${PathCname}.m<< EOF
    if (m > mu)
      % fprintf("# MM peel m: %d x %d x %d\n",m-mu,k,n)
EOF
echo "      C(mu+1:m,1:n)=C(mu+1:m,1:n)+${Fname}(A(mu+1:m,1:k),B,nmin, level);" >> ${PathCname}.m
cat >> ${PathCname}.m<< EOF
    end
    if (k > ku) && (mu > 0) && (nu > 0)
      % fprintf("# MM peel k: %d x %d x %d\n",mu,k-ku,nu)
EOF
echo "      C(1:mu,1:nu)=C(1:mu,1:nu)+${Fname}(A(1:mu,ku+1:k),B(ku+1:k,1:nu),nmin, level);" >> ${PathCname}.m
cat >> ${PathCname}.m<< EOF
    end
    if (n > nu) && (mu > 0)
      % fprintf("# MM peel n: %d x %d x %d\n",mu,k,n-nu)
EOF
echo "      C(1:mu,nu+1:n)=C(1:mu,nu+1:n)+${Fname}(A(1:mu,1:k),B(1:k,nu+1:n),nmin, level);" >> ${PathCname}.m
cat >> ${PathCname}.m<< EOF
    end
  else
EOF
echo '    if l>=level, fprintf("# Core'"<$m;$k;$n>"'[%d]: %d x %d x %d\n",l,m,k,n); end' >> ${PathCname}.m

./replacer $Lslp i o A $m $k $r 1 >> ${PathCname}.m
./replacer $Rslp i o B $k $n $r 1 >> ${PathCname}.m

set j = 0
while ( $j < $r )
   echo "iC$j = $Fname( oA$j, oB$j, nmin, level);" >> ${PathCname}.m
   @ j++
end
echo >> ${PathCname}.m

./replacer $Pslp i o C $m $n $r 0 >> ${PathCname}.m
cat >> ${PathCname}.m<< EOF
  end
end
end
EOF


if ( -f ${PathFname}.m ) then
    echo -n "Overwrite ${PathFname}.m (y/n)? "
    set answer = $<
    if ("$answer" != "y") then
	exit;
    endif
endif

echo "Writing high-level MM routine to ${PathFname}.m"

echo "function C = $Fname(A, B, nmin, level)" > ${PathFname}.m
echo "%          Computes the product C = A*B, with fast core: <$m;$k;$n>." >> ${PathFname}.m
echo "%          nmin : threshold switch to conventional." >> ${PathFname}.m
echo "%          level: logging level." >> ${PathFname}.m
echo "  if nargin < 3, nmin = min([$m,$k,$n]); end" >> ${PathFname}.m
echo "  if nargin < 4, level = 3; end" >> ${PathFname}.m
echo "  [m,k] = size(A); [k,n] = size(B);" >> ${PathFname}.m
echo "  C=${Cname}(A,B,nmin,level);" >> ${PathFname}.m
echo "end" >> ${PathFname}.m
